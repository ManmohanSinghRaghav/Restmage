# -*- coding: utf-8 -*-
"""RestMage.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DpQOQCW_j21SJme5JCj1ISjZFEQpHhMH
"""

import google.generativeai as genai
import json
import os
from pydantic import BaseModel, Field
from typing import List

# Remove Colab-specific import that breaks non-Colab environments
# from google.colab import userdata
# userdata.get('GOOGLE_API_KEY')

import json
import matplotlib.pyplot as plt
import matplotlib.patches as patches

def get_orientation(pos, walls_list):
    """
    Helper function to determine if an object at 'pos'
    is on a 'horizontal' or 'vertical' wall.
    """
    px, py = pos['x_ft'], pos['y_ft']

    for wall in walls_list:
        x1, y1 = wall['start']['x_ft'], wall['start']['y_ft']
        x2, y2 = wall['end']['x_ft'], wall['end']['y_ft']

        # Check for vertical wall
        if x1 == x2 == px and min(y1, y2) <= py <= max(y1, y2):
            return 'vertical'
        # Check for horizontal wall
        if y1 == y2 == py and min(x1, x2) <= px <= max(x1, x2):
            return 'horizontal'

    return 'unknown' # Fallback

def get_polygon_centroid(polygon_points):
    """Calculates the center of a room polygon to place its label."""
    x_coords = [p['x_ft'] for p in polygon_points]
    y_coords = [p['y_ft'] for p in polygon_points]
    return (sum(x_coords) / len(x_coords), sum(y_coords) / len(y_coords))

import google.generativeai as genai
import json
import os
from pydantic import BaseModel, Field
from typing import List, Optional

# --- 1. Define the Full Architect-Level JSON Schema ---
# Verified against API limitations (no 'default' field)

class MapInfo(BaseModel):
    """Contains all the essential metadata for a map."""
    title: str = Field(description="The title of the floor plan.")
    author: str = Field(description="The entity that generated the map, e.g., 'Gemini AI Architect'.")
    date: str = Field(description="The date of generation, e.g., 'October 23, 2025'.")
    scale: str = Field(description="The map scale, e.g., '1:100' or '1/8\" = 1'0\"'.")
    north_direction: str = Field(description="The direction of North, e.g., 'Top of map', 'East'.")

class Point(BaseModel):
    """A single 2D coordinate point."""
    x_ft: float
    y_ft: float

class Room(BaseModel):
    """Defines the floor area of a single room by its boundary points."""
    name: str = Field(description="The common name of the room (e.g., 'Master Bedroom').")
    type: str = Field(description="Category (e.g., 'bedroom', 'kitchen', 'hallway').")
    polygon: List[Point] = Field(description="A list of (x,y) points defining the room's floor boundary.")

class Wall(BaseModel):
    """A single wall segment."""
    start: Point
    end: Point
    thickness_ft: float = Field(description="Wall thickness, e.g., 0.75ft for 9in brick.")

class Door(BaseModel):
    """A door opening."""
    position: Point = Field(description="The center point of the door on a wall.")
    width_ft: float = Field(description="The width of the door opening.")
    swing: str = Field(description="Swing direction, e.g., 'in-left', 'in-right'.")

class Window(BaseModel):
    """A window opening."""
    position: Point = Field(description="The center point of the window on a wall.")
    width_ft: float = Field(description="The width of the window opening.")

class Stair(BaseModel):
    """A staircase."""
    footprint: List[Point] = Field(description="The (x,y) polygon outlining the stairs on the floor.")
    direction: str = Field(description="e.g., 'UP' or 'DOWN' from this floor.")
    steps: int = Field(description="The number of steps.")

class Fixture(BaseModel):
    """A fixed architectural object, like a sink or toilet."""
    position: Point = Field(description="The (x,y) center point of the fixture.")
    type: str = Field(description="The type of fixture, e.g., 'toilet', 'sink', 'stove', 'shower'.")
    rotation: float = Field(description="Rotation in degrees (0-360). 0 is facing 'East'.")

class PlotSummary(BaseModel):
    """Defines the boundary of the land."""
    plot_width_ft: float
    plot_length_ft: float
    setback_front_ft: float
    setback_rear_ft: float
    setback_side_left_ft: float
    setback_side_right_ft: float

class FloorPlan(BaseModel):
    """The root object for the entire architect-grade floor plan."""
    map_info: MapInfo
    plot_summary: PlotSummary
    rooms: List[Room]
    walls: List[Wall]
    doors: List[Door]
    windows: List[Window]
    stairs: List[Stair]
    fixtures: List[Fixture]

# --- 2. Helper Functions ---

def get_api_key():
    """Gets the API key from an environment variable or user input."""
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        try:
            # Check for Colab environment
            import google.colab
            from google.colab import userdata
            api_key = userdata.get('GOOGLE_API_KEY')
        except (ImportError, ModuleNotFoundError, KeyError):
            # In API mode, don't prompt for input
            # print("API Key not found in environment variables.")
            # api_key = input("Please paste your Google AI API key and press Enter: ")
            pass
    return api_key

def save_json_string_to_file(json_string: str, filename: str):
    """Saves a JSON string to a file with pretty-printing."""
    try:
        # Load the string into a Python dict to validate it and pretty-print
        data = json.loads(json_string)
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        print(f"\nSuccessfully saved floor plan to '{filename}'")
    except json.JSONDecodeError:
        print(f"\nModel returned invalid JSON, which should not happen with a schema. Saving raw text to '{filename}.txt'")
        with open(f"{filename}.txt", 'w') as f:
            f.write(json_string)

# --- 3. The Full Architect Prompt ---

def create_architect_prompt(inputs: dict) -> str:
    """Creates the final, most detailed architect-level prompt."""

    return f"""
You are a licensed AI Architect. Your task is to generate a complete 2D floor plan with all architectural details.
You must generate all individual map elements: rooms, walls, doors, windows, stairs (if needed), and standard fixtures. You must provide values for all fields in the schema.

--- USER REQUIREMENTS ---
- Plot Dimensions: {inputs['plot_width_ft']}ft Width x {inputs['plot_length_ft']}ft Length
- Entrance Facing: {inputs['entrance_facing']}
- Setbacks: {inputs['setback_front_ft']}ft (Front), {inputs['setback_rear_ft']}ft (Rear), {inputs['setback_side_left_ft']}ft (Left Side), {inputs['setback_side_right_ft']}ft (Right Side)
- Required Rooms: {inputs['rooms']}
- Location Context: Mathura, India (Vastu compliance is important)
- Floors: {inputs['floors']}

--- ARCHITECTURAL RULES ---
1.  **Vastu Shastra:**
    * Kitchen in Southeast (Agneya).
    * Master Bedroom in Southwest (Nairutya).
    * Pooja Room in Northeast (Ishanya).
    * Bathrooms in Northwest (Vayavya) or West.
2.  **Setbacks:** All construction must be *inside* the setback lines.
3.  **Circulation:** Include a 'hallway' for access to private rooms. If floors > 1, you MUST include a 'Stair' object.
4.  **Fixtures:** You MUST add standard fixtures.
    * **Bathrooms:** Add one 'toilet' and one 'sink' in each bathroom.
    * **Kitchen:** Add one 'kitchen_sink' and one 'stove'.
5.  **Completeness:** Generate all `walls`, `doors`, `windows`, `stairs`, and `fixtures`.
6.  **No Overlaps:** All elements must be spatially coherent.

Generate the complete JSON response that precisely follows the `FloorPlan` schema.
"""

# --- 4. Main Execution Block (with Streaming) ---
def main(width=30, length=50.0, entrance_facing="North", setback=[5, 3, 3, 3], rooms="2 Bedrooms, 2 Bathrooms, 1 Living Room, 1 Kitchen, 1 Pooja Room", floors=1):
    # 1. Define the "Dummy Data" from the user
    user_inputs = {
        "plot_width_ft": width,
        "plot_length_ft": length,
        "entrance_facing": entrance_facing,
        "setback_front_ft": setback[0],
        "setback_rear_ft": setback[1],
        "setback_side_left_ft": setback[2],
        "setback_side_right_ft": setback[3],
        "rooms": rooms,
        "floors": floors # Set to 1 for no stairs, 2 for stairs
    }

    # 2. Configure the API
    try:
        api_key = get_api_key()
        # Use the stable google-genai library
        genai.configure(api_key=api_key)
    except Exception as e:
        print(f"Error configuring API: {e}")
        exit()

    # 3. Create the prompt and config
    prompt = create_architect_prompt(user_inputs)

    generation_config = genai.types.GenerationConfig( # Use the explicit type for stability
        response_mime_type="application/json",
        response_schema=FloorPlan, # Use our most complex schema
    )

    # Use the stable version of the most capable model
    # Note: 'gemini-1.5-pro-latest' often points to the stable version.
    # For guaranteed stability, you might use a specific version like 'gemini-1.5-pro-001' if available,
    # but 'latest' is usually fine.
    model = genai.GenerativeModel('gemini-2.5-flash')

    print("Generating 'architect-grade' floor plan (with Vastu)...")
    print("--- Start of Stream ---")

    try:
        # 1. Add stream=True
        response_stream = model.generate_content(
            prompt,
            generation_config=generation_config,
            stream=True
        )

        # 2. Loop over the stream and build the full response
        full_response_text = ""
        for chunk in response_stream:
            if chunk.parts: # Check if parts exist before accessing text
                 if chunk.parts[0].text:
                    print(chunk.parts[0].text, end="", flush=True) # Print chunk immediately
                    full_response_text += chunk.parts[0].text
            elif chunk.text: # Fallback for potential direct text in chunk
                print(chunk.text, end="", flush=True)
                full_response_text += chunk.text

        print("\n--- End of Stream ---")

        if full_response_text:
            save_json_string_to_file(full_response_text, "floor_plan_complete.json")
            print("\nGeneration complete. The file 'floor_plan_complete.json' now contains the full dataset.")
        else:
            print("\nError: No text was generated by the model.")

    except Exception as e:
        print(f"\nAn error occurred during generation: {e}")
        # Optionally print the last partial response if available
        # if 'response_stream' in locals() and hasattr(response_stream, '_buf'):
        #    print("Partial response received before error:", response_stream._buf)

def visualize_architect_plan(json_filepath):
    """
    Reads a professional-grade floor plan JSON and visualizes it
    with all components.
    """
    try:
        with open(json_filepath, 'r') as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"Error: The file '{json_filepath}' was not found.")
        return
    except json.JSONDecodeError:
        print(f"Error: The file '{json_filepath}' is not valid JSON.")
        return

    # Extract all data components
    plot = data.get('plot_summary', {})
    rooms = data.get('rooms', [])
    walls = data.get('walls', [])
    doors = data.get('doors', [])
    windows = data.get('windows', [])
    info = data.get('map_info', {})

    # --- 1. Set up the Plot ---
    # The plot is 30x50, so a 10x15 figure is a good ratio
    fig, ax = plt.subplots(figsize=(10, 15))
    ax.set_title(info.get('title', 'Floor Plan'), fontsize=16)
    ax.set_aspect('equal') # 1ft on x-axis = 1ft on y-axis

    # --- 2. Draw Plot Boundary & Setbacks ---
    plot_w = plot.get('plot_width_ft', 30)
    plot_l = plot.get('plot_length_ft', 50)

    # Draw the main plot boundary
    plot_boundary = patches.Rectangle((0, 0), plot_w, plot_l,
                                      facecolor='none', edgecolor='black',
                                      linewidth=2, label='Plot Boundary')
    ax.add_patch(plot_boundary)

    # Calculate and draw the buildable area (setback lines)
    bx = plot.get('setback_side_left_ft', 0)
    by = plot.get('setback_front_ft', 0)
    bw = plot_w - bx - plot.get('setback_side_right_ft', 0)
    bl = plot_l - by - plot.get('setback_rear_ft', 0)

    buildable_area = patches.Rectangle((bx, by), bw, bl,
                                       facecolor='none', edgecolor='gray',
                                       linestyle='--', label='Buildable Area')
    ax.add_patch(buildable_area)

    # --- 3. Draw Rooms (as filled polygons) ---
    for room in rooms:
        poly_coords = [(p['x_ft'], p['y_ft']) for p in room['polygon']]
        room_poly = patches.Polygon(poly_coords, facecolor='lightblue',
                                  alpha=0.6, edgecolor='blue',
                                  linestyle=':')
        ax.add_patch(room_poly)

        # Add room label at its center
        cx, cy = get_polygon_centroid(room['polygon'])
        ax.text(cx, cy, room.get('name', 'Room'),
                ha='center', va='center', fontsize=9, color='black')

    # --- 4. Draw Walls (as thick black lines) ---
    for wall in walls:
        x_coords = [wall['start']['x_ft'], wall['end']['x_ft']]
        y_coords = [wall['start']['y_ft'], wall['end']['y_ft']]
        # Multiply thickness by a factor to make it visible (e.g., 8)
        thickness = wall.get('thickness_ft', 0.5) * 8
        ax.plot(x_coords, y_coords, color='black', linewidth=thickness, zorder=5)

    # --- 5. Draw Doors (as brown rectangles) ---
    for door in doors:
        pos = door['position']
        width = door['width_ft']
        orientation = get_orientation(pos, walls)

        if orientation == 'vertical':
            # Draw a vertical door
            door_patch = patches.Rectangle(
                (pos['x_ft'] - 0.5, pos['y_ft'] - width/2),
                1.0, width, facecolor='brown', zorder=10)
        elif orientation == 'horizontal':
            # Draw a horizontal door
            door_patch = patches.Rectangle(
                (pos['x_ft'] - width/2, pos['y_ft'] - 0.5),
                width, 1.0, facecolor='brown', zorder=10)
        else:
            continue # Skip if we can't place it
        ax.add_patch(door_patch)

    # --- 6. Draw Windows (as cyan rectangles) ---
    for window in windows:
        pos = window['position']
        width = window['width_ft']
        orientation = get_orientation(pos, walls)

        if orientation == 'vertical':
            # Draw a vertical window
            window_patch = patches.Rectangle(
                (pos['x_ft'] - 0.25, pos['y_ft'] - width/2),
                0.5, width, facecolor='cyan', edgecolor='black', zorder=10)
        elif orientation == 'horizontal':
            # Draw a horizontal window
            window_patch = patches.Rectangle(
                (pos['x_ft'] - width/2, pos['y_ft'] - 0.25),
                width, 0.5, facecolor='cyan', edgecolor='black', zorder=10)
        else:
            continue
        ax.add_patch(window_patch)

    # --- 7. Finalize and Show Plot ---
    ax.set_xlim(-5, plot_w + 5)
    ax.set_ylim(-5, plot_l + 5)
    ax.set_xlabel("Width (feet)")
    ax.set_ylabel("Length (feet)")
    ax.grid(True, linestyle=':', alpha=0.5)
    plt.legend()
    plt.show()

# Comment out the main execution to prevent auto-run when imported as module
# Uncomment to run as standalone script
# main(
#     width=60.0,
#     length=40.0,
#     entrance_facing="west",
#     setback=[3, 3, 3, 3],
#     rooms="2 Bedrooms, 3 attached Bathrooms, 1 Living Room, 1 Temple, 1 Kitchen, 1 Guestroom",
#     floors=1)

